# Chapter 4 : 木とグラフ

## 木の種類
木は根（root）ノードと子ノードを持つデータ構造である．閉路のない連結グラフとも言える．
```
class Node{
  public String name;
  public Node[] children;
}
```
が基本的なクラス定義である．

### 二分木
各ノードが最大２個の子を持つ木を二分木という．子ノードを持たないノード（木の末端）を葉ノードという．

### 二分探索木
二分探索木とは全てのノードが特定の並び順に従っているものである．
この並び順はノード直下の子だけでなく，その先の子孫全てに関して成立していなくてはならない．

### 完全二分木，全二分木
- Complete binary tree：最深ノード以外の全てのノードが満たされている木
- Full binary tree：全てのノードが０個か２個の子を持つ木
- Perfect binary tree：上二つ両方を満たす木．ほとんどない

### 二分木の走査
- In-Order (popular)：左の枝→現在のノード→右の枝の順の走査．深さ優先探索．
- Pre-Order：現在のノード→子ノード
- Post-Order：子ノード→現在のノード．根を最後に訪れることになる．

### 二分ヒープ
（最小ヒープ）全てのノードが子ノードよりも小さい完全二分木（completeの方）．根が最小値を持つ．

要素の挿入と追加がO(logn)でできる．ダイクストラ法やプリム法など，値の追加と最小要素の取り出しが多い場合に有効．
- 挿入：木の最後（最深部の最も右側）に値を追加．大小関係の変更がなくなるまで追加したノードと親ノードとの入れ替えを行う．
- 最小要素の取り出し：取り出し自体は根の要素を取り出すだけ．その後ヒープの末尾（右下）の要素を根に移動させ，子ノードの小さい方と入れ替えていく．

### トライ木
各ノードの要素に文字を保持するn分木の一種．木の経路が単語を表す．接頭辞検索用に言語全体（英語）を保持する場合によく使われる（？）．

## グラフ
ノード（頂点）とそれを繋ぐエッジ（辺）からなるデータ構造．有向グラフと無向グラフがある．
任意の2頂点間に経路が存在するグラフを連結グラフという．
グラフは閉路を持つ場合や同じ頂点同士を別のエッジが結ぶ場合もある．

### グラフの表現方法
- 隣接リスト：全ての頂点に対して隣接する頂点のリストを保持する．
- 隣接行列：頂点数x頂点数の行列を用意し，各要素に連結しているかしていないかを保持する．メモリを食う．

### グラフ探索
- 深さ優先探索(DFS: depth-first search)：訪れるノードをスタックして管理する．
- 幅優先探索（BFS: breadth-first search）：訪れるノードをキューで管理する．ゴールがスタート近くにありそうな時に有効
- 双方向探索：二つのノードの最短経路を見つけるのに使われる．二つのノードそれぞれから幅優先探索を行い，衝突したらそれが最短経路．

## 問題
#### 4.1 ノード間の経路
DFSでもBFSでも可能．訪れたノードは管理して無限ループしないように．

#### 4.2 最小の木
中央値で分ける→分割する→を繰り返す．

#### 4.3 深さのリスト
探索時に現在の深さを管理して各連結リストを作成．

#### 4.4 平衡チェック
各ノードに対して部分木の高さを計算すれば良い．素直にやると高さの計算を重複して行いO(nlogn)になってしまう．
ルートから再帰的に降下しながら高さのチェックを行うとO(n)の時間計算量で可能．

#### 4.5 BSTチェック
- 解法１：In-Orderの探索：訪れた順に配列へコピーし，その配列がソートされているかを確認する．重複した値がある場合は適切に処理できない．
配列を使わなくても，最後に調べた要素だけ保持しておき，それとの比較だけでも可能．
- 解法２：min/max解法：二分探索木の定義はあるノードの値はそれより左側の全ノードの値より大きく，右側の全ノードの値より小さいこと．
なので最小値と最大値を保持して，それと比較しながら木を降りていけばいい．

#### 4.6 次のノード
In-Orderにおける「次」のノードは，現在のノードから見て右の最も手前（左）のノードである．
現在のノードが右の部分木を持たない場合は，部分木の探索は終了しているので親ノードを調べる．
現在のノードが親ノードの左なら，次のノードは親．右側なら訪れていない親まで遡る．
上位ノードも全て探索済みの場合（in-orderの最後）はnullを返すようにする．丁寧に全パターンを想定することが必要．

## Introduction

1. **面接の流れ**

2. **面接試験の舞台裏**  

3. **特殊な状況**  

4. **面接の前に**

5. **行動に関する質問**

6. **ビッグオー記法(Big O)**

7. **技術的な質問**

8. **オファーとその後**

## 1. 面接の流れ

　面接官の評価基準
 
- 分析スキル：与えられた問題に対して適切な解決方法を導けたか？どの程度時間がかかったか？どの程度助けを必要としたか？
- コーディングスキル：考えを的確に実装できているか？エラーの可能性は想定されているか？
- CS分野の基礎知識：文字通り．
- 経験：これまでの技術的な経験で，的確に決定を下してきたか？重要な役割を，どのように果たしたか？
- 企業文化との相性：考え方や価値観は企業全体やチームの文化と合致しているか？

アルゴリズム系の問題では前3つが重視される．

**偽陰性（良い人材の取りこぼし）は許容される**．

対して偽陽性（面接では高評価だったのに実際は．．．）の方が問題とされる．切り替えていこう．

**データ構造とアルゴリズムに関する基礎知識**

データ構造などの知識そのものの価値もあるが，そうした知識を備えていることがある程度のCS分野の学習経験の担保となる．

**ホワイトボードでのコーディング**

開発そのものと，開発におけるコミュニケーション能力の両方を評価できる．できているところとわからないところをきちんと言語化するのも開発力．練習必須．

**どんな問題が出るか？**

面接する人がその都度決めている（らしい）．近道はない．

**評価は相対評価**

難しい問題がでても諦めずにがんばろう．
 
## 2. 面接試験の舞台裏

書籍ではMicrosoft,Amazon，Google,Apple，Facebook，Palantirについて簡単な説明がある．Web系の企業は大規模システムの設計やスケーラビリティを重視する．あとはポストに関連する知識はどこでも重要．

## 3. 特殊な状況

**職歴の長い候補者，テスターとSDET，PM，開発リーダー・マネージャ**

新卒でなくても，応募するポストで求められる能力はしっかり検討・準備しておかないといけない（あたりまえ）．

**スタートアップ企業，合併買収による人材獲得，面接官に向けたアドバイス**

飛ばします．面接って大変．

## 4. 面接の前に

**経験**

学生のうちにできる，アピールできる経験
- 開発を行う授業：グループで開発する授業なんかは独学では得られない経験になります．
- 技術系インターンへの参加：企業がどんな技術に着目してて，学生に何を求めてるのかを知る経験になります．
- 率先して取り組んだ経験：技術系に限らず，何かのモチベーションに基づいて物事に取り組む経験は他の人と被りづらいユニークな経験になると思います．

企業が知りたいのは候補者の賢さとコーディング能力．新卒でも自分のキャリア像やその業界での目指す人物像が描けているとなお良い気がする．
この辺と自分の経験談を絡められると説得力のあるアピールができそう．

**履歴書・プロジェクト**

履歴書に書く内容は長すぎず，応募するポストに関連することを書く．自分が果たした経験に関しては「問題に対して対策を立てて結果どうなったか」という起承転結をベースにするとわかりやすい．個人的には大学（院）での研究もこの流れでアピールできると思う．複数あるなら効果的にアピールできるのをピックアップ．

**言語とソフトウェア**

ソフトウェアに関しては，わざわざアピールするものか吟味する必要がある．私はあまり記憶にないです．なにならアピールできるのだろう．

言語に関しては経験年数よりも習熟度合い（専門，熟練，経験あり，など）で記載すべき．まあ学生なら同じようなものかもしれませんが．

**英語での履歴書**

ネイティブかそれに近い語感を持った人に確認してもらうのがベター

**プログラミング言語に関する潜在的な悪印象には注意しよう**

一つの言語にフォーカスしすぎない．幅広い経験が重要．

**面接までのロードマップ**

本誌参照．準備は計画的に！

## 5. 行動に関する質問

**経験の振り返りと見つめ直し**

これまでの経験について，１．苦労したこと，2.過失・失敗，3.楽しんだこと，4.リーダーシップ，5.衝突，6.やり方を変えてみたこと，を整理してみる．できるだけ自分が主役なものの方がアピールしやすい．研究に関しても同様，特に1.3.4.6なんかが個人的には重要な気がする．困難なことがあり，それに対してどう考えて取り組んだのかが整理できていると良い．

**逆質問**

- 純粋な質問：役職内容の比率は？面接担当官のモチベーションや印象深い経験は？
- 洞察を示す質問：応募企業のプロダクトやシステムに関する質問．リサーチが必要だが自分の知識をアピールできる．応募の情熱も伝わる．
- 情熱を示す質問：応募企業で学べる技術や得られる経験への興味など

**質問への対応**

- ただの自慢になることを避けるためには，具体的に事実を伝えるのが効果的．
- いきなり詳細を話しすぎず，まずはキーポイントをコンパクトに説明する．エピソードの結果とそのインパクトまず伝えられると良い．
- チームの中での経験でも，自分自身にフォーカスした話を心がける．
- 構造化した回答：話す内容について，状況・行動・結果を簡潔にして話すとわかりやすい．つまり「何を，どうして，どうなったか」．論文や研究発表で現状・問題意識，から手法の提案，実験結果とディスカッションという流れと同じ．

**行動の意義を考える**

各状況でとった行動にはどのような意味があったのか？何を意図してその行動をとったのか？を見つめ直す．

例：リーダーシップ，共感，思いやり，謙虚，チームワークなど，

**あなた自身のことについて．．．**

自分をどのように伝えたいか？を踏まえた上で経歴や経験をまとめる．趣味に関しては話してもマイナスになることはほぼない．応募内容と絡められるならどんどん話すと良い．

## 6. ビッグオー記法(Big O)

アルゴリズムに対する時間計算量の表記方法．

例：ファイル（サイズs）の送信
- 電子的な送信（メールなど）：O(s)：ファイルサイズに比例した実行時間
- 物理的な送信（ハードディスクの運搬）：O(1)：基本的にどんな大きさのファイルでも同じ時間で送信可能

言語にもよるが，O(80,000,000)で1秒くらい．

**空間計算量**

メモリも有限なので，巨大な配列を作るのは注意が必要．長さnの配列ならO(n)のメモリ領域，nxnの配列ならO(n^2)のメモリ領域が必要になる．

**定数を捨てる．小さい項を捨てる**

- ビッグオー記法は計算量の増加の割合を示すだけなので，O(n)がO(1)よりも早いということはあり得る．同時に，O(2n)は係数の２を考えずにO(n)と表記する．
- 影響の少ない項は捨てる．例えばO(n^2+n)はO(n^2)．大体の順番としてはO(logn)<O(n)<O(nlogn)<O(n^2)<O(2^n)<O(x!)になる．ただし，独立の変数が存在する場合はO(n+m)などとなることもありうる．

**実行時間を足す場合，掛ける場合**

2つの処理A,Bについて，
- Aを完了した後にBを行う場合：O(A+B)
- A内の各処理で毎回Bを行う場合：O(AB)

**LogN実行時間**

二分探索系のアルゴリズム（探索対象が毎回半分になるようなもの）はO(logn)になることが多い．ビッグオー記法では定数は無視するので，対数の底はなんでも良い．

**再帰処理の実行時間**

書籍だと探索対象が毎回２倍になるアルゴリズムが掲載されている．これはO(2^n)となる．再帰関数内での関数の呼び出し数を枝の数とすると，実行時間はO(枝の数^深さ)になることが多い．指数以上のオーダーはすぐ発散するので注意が必要（それが最善なこともあるが）．

基本的にはfor文（や繰り返し処理）がどのように重なっているかを意識するとビッグオーの計算がしやすいように感じる．競プロでは必須スキル．

## 7. 技術的な質問

**問題の取り組み方**

- まず自分で解いてみる．
- コードを紙に書いてみる．どんな関数が必要か？
- テストケースもリストアップしてみる．一般的なケース，基本ケース，エラーケースなどを想定する．
- 紙に書いたコードを実際にコーディングしてみて動くかどうかを確認する．

**必須のデータ構造，アルゴリズム，概念**

コーディング面接は知識を問うものではないが，基本的な内容は知っている必要がある．

- データ構造：連結リスト，木，スタックとキュー，ヒープ，配列，ハッシュテーブル
- アルゴリズム：幅優先探索，深さ優先探索，二分木，マージソート，クイックソート
- 概念：ビット操作，メモリ（スタックとヒープ），再帰，動的計画法，ビッグオー表記，スペース（？）

**解答フロー**

1. 問題をよく聞く：入出力は？入力の状態は？
2. 例を考える：特別なケースではない，例として汎用なケースを考える．
3. ブルートフォースで書いてみる：力技（全探索とか）ではどうなるか？
4. 最適化する：ブルートフォースのアルゴリズムで同じ処理や省略できる処理などはないか？
5. 見直す：アルゴリズムを見直して理解を深める．
6. 実装する：綺麗なコード（必要に応じたモジュール化，もれのないエラーチェック，わかりやすい変数名など）を心がける．
7. テストする：コンセプトテスト（コードの各行の解説，意図した通りに動くか？），ミスを誘発する処理（i=1で始まるforループなど），ホットスポット（再帰の終了条件，整数値の除算など），小さなテストケースの利用，特殊なケースでの検証．

**最適化の着眼点**

- BUD:Bottleneck, Unnecessary work, Duplicated work
- ボトルネック：処理全体を遅くしている処理はどこか？
- 不必要な処理
- 重複する処理

**その他の着眼点**
- 直感的にはどうやって解いているか？
- 単純化と一般化
- 初期状態からの積み上げ：再帰アルゴリズムになることが多い
- データ構造総当たり：特定のデータ構造によってうまく問題が解けることは多い．問題に対して各データ構造の性質が適しているかを一通り考えるのも一つの手段．

**Best Convergence Runtime**

問題に対してあり得る最善の実行時間のこと．これを意識すると良いアルゴリズムの発想の繋がる（ことがある）．また，その問題における時間計算量の上限を知っておけるので，試行錯誤を打ち切る目安になる．

**正しくない解答の扱い**

- コーディング面接の評価は解法を導く過程やそれがどれくらい洗練されているかなど多岐にわたる．単純な正誤で測られるだけではない．
- コーディング面接の評価は基本的に他の候補者との相対評価で決まる．
- 面接で出される多くの問題は即座に解答できるものではない．

**面接で用いるプログラミング言語**

特定の言語を支持されることはほぼないため，自分が得意な言語で臨める．ただしディスカッションする以上ある程度は面接官が知っており，読みやすい言語が望ましいと思う．

**綺麗なコードとは**

- 正確：考えうるどんな入力にも正しく動作する．
- 効率的：時間計算量，空間計算量を考慮している．
- シンプル
- 読みやすい：他の開発者がみてもわかるコーディング．
- 保守性

これらの間でトレードオフが発生することもある．バランスが大事．

**独自のデータ構造**

問題によっては独自のデータ構造を定義すると良いかもしれない．過度な最適化かもしれないが，できる限り効率的なコードを考えるのは有意義である．

**その他**

- コードの再利用：煩雑に関数を定義しない．まとめられる関数がないか気を配る．
- モジュール化：複雑なコードに関してはモジュール化によってテストがしやすくなる．可読性や保守性にも貢献する．
- 柔軟かつ堅牢：できるなら，より一般的な問題を想定する．その状況でも動くコードを考える．一方で問題の複雑さに関しては面接官に確認するのもアリだと思う．
- エラーチェック：入力に対して勝手な仮定をしない．エラーの可能性に気を配る．

**諦めない！**

## 8. オファーとその後

- 採用の場合：オファーの期限や待遇，キャリアにおける意味を吟味する
- 不採用の場合：採用は運もあるので気持ちを切り替える．リクルーターからフィードバックを得られる場合もある．
